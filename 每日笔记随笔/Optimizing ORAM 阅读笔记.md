# 2018/4/12
1. 和原始的tree-ORAM相比减少了时间空间复杂度，然后设计了一个二分搜索协议，能实现范围查询和关键字查询
2. 它使用了一点同态加密     
>亚线性（sublinear），用于描述量与量之间的一种变化关系，例如y=a+b*x^n，其中0<n<1。当n=1时，表示为线性关系，当n>1时，表示为超线性关系。
3. 同态加密用来减少client的计算和通信复杂度的
4. 论文里面的时间空间复杂度是怎么计算出来的没弄懂
5. 它直接使用了递归结构并且层数是4？
6. >按照这篇论文的解释，如果发生写操作，新的数据块是存入root中的，为了防止root桶溢出，才要进行驱逐操作
得去看看代码里面的驱逐操作的循环体，看看每层的驱逐操作的关系
7. 驱逐操作，是在每层节点随机选择2个节点，先解密，然后检查节点是否有新写入的桶，有的话就驱逐到它的随机儿子节点中，并且他是client在每次驱逐操作过程中都把节点和儿子节点下载下来，计算完毕后再上传上去替换的。
8. 两个优化  
    5.1. 减小树高   
        - 增加叶节点大小到2倍，能j减小移出概率；    
        - 增加树的degree不使用2叉树而是K叉树   
>S3ORAM的还是二叉树
9. 新的驱逐策略。尽量把一个块沿着路径L向下驱逐的够远。比如说路径L中的一个块被分配了新的路径L'，那么将块驱逐到L和L'的最近公共祖先，然后在开始正常驱逐。
10. 茫然的搜索，只用一个ORAM访问：它是在递归结构中做得。    
大致是将每个地址贴上一个标签，对标签排序，然后将access过程替换成Binary Search.
我的理解是在每次访问过程中，根据它对每层的ORAM的分出来的区间，在每层ORAM的每个区间按照排好序的索引进行查找，并且查找过程是一次client访问将整条路径的bucket读到客户端中,解密，在每个ORAM entry中查找，然后替换，加密上传
    >感觉和Path-ORAM类似啊      
11. 它实现了一个范围查询和关键字查询
### 范围查询
在给定范围的下界上进行二分查找，然后找比它大的，直到超过上界
### 关键字查询
建立一个反转索引，建立一个对每个关键字的不同地址的索引，然后查找

## 同态加密部分
1. 在MPC-over-ORAM中，client也是不能知道访问的逻辑地址和返回的值
2. 同态的访问不太明白
3. 同态后的驱逐可以由server非交互的完成。
