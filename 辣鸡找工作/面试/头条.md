# 一面
## 编程题
1. 山谷积水
给定一个一维数组，每个元素表示一个海拔高度。下雨之后低洼的地方会积水，假设雨水足够，能填满所有的低洼地方，计算下雨后所有低洼地段的总蓄水量。    
例如给定数组5 2 1 4 3，下雨后，各个地方算上雨水会被填充为5 4 4 4 3，一共填充了5个单位的雨水。   
输入描述    
第一行一个整数N，表示数组长度。N <= 1e6 
第二行N个整数，表示N个海拔高度。每个高度不超过1e6   
输出描述    
输出一个数字。  
```
leetcode原题，直接左右游标夹逼就好了
class Solution {
public:
    int trap(vector<int>& height) {
        int l = 0, r = height.size()-1;
        int Min = 0, sum = 0;
        while (l < r) {
            Min = min(height[l], height[r]);
            if (Min == height[l]) {
                l++;
                while (l < r && height[l] <= Min) {
                    sum += Min - height[l];
                    l++;
                }
            }
            else {
                r--;
                while (l < r && height[r] <= Min) {
                    sum += Min - height[r];
                    r--;
                }
            }
        }
        return sum;
    }
};
```

2. 给你一个数字n(n < 1e9),再给你一个数字k(k < n),要求你找到1,2,3,...,n按照字典序排序后，第k小的数字；
如n=15, k=7;
那1 ~ 15按照字典序排序为:1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9;
则答案为15
说明：不能用类库的sort函数，时间复杂度尽量小
```
也是leetcode原题
class Solution {
public:
    int findKthNumber(int n, int k) {
        int ans = 1;
        k--;
        while (k > 0) {
            int cnt = 0;
            for (long long f = ans, s = f + 1; f <= n; f *= 10, s *= 10)
                cnt += min((long long)n + 1, s) - f;
            if (cnt <= k) {
                k -= cnt;
                ans++;
            } else {
                k--;
                ans *= 10;
            }
        }
        return ans;
    }
};
```

## 编程语言
1. C++ 能不能用对象的引用做返回值？

（1）以引用返回函数值，定义函数时需要在函数名前加 &
（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

引用作为返回值，必须遵守以下规则：

（1）不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
（2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
（3）可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
(可以理解成  可能将类的私有成员暴露在外部接口上)

2. 栈变量和堆变量有什么区别？栈的大小有限制吗？指针是什么变量？

Linux系统：

    ulimit -a #显示当前用户的栈大小
    ulimit -s 32768 #将当前用户的栈大小设置为32M bytes

指针都在栈上

3. C++有几种map，你知道哪些？

4. tree map跟hash map有什么优缺点，适应于什么场景？

优缺点以及适用处
    map：

    优点： 
    有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
    红黑树，内部实现一个红黑树使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
    缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间

    适用处：对于那些有顺序要求的问题，用map会更高效一些

    unordered_map：

    优点： 因为内部实现了哈希表，因此其查找速度非常的快
    缺点： 哈希表的建立比较耗费时间
    适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map
总结： 
1. 内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。 
2. 但是unordered_map执行效率要比map高很多 
3. 对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的

map和unordered_map的使用
unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。

5. 堆排序建堆复杂度？

<font color= red size=5>O(n)</font>

6. 变量的初始化和赋值有什么区别？

int i = 2

int i;
i = 2;
效率是一样的吗？为什么？


## 网络
1. UDP和TCP的理解
https://blog.csdn.net/xiaobangkuaipao/article/details/76793702
2. TCP是有连接的是指什么？他在IP的基础上实现了哪些功能？

3. 描述下滑动窗口/四次挥手。

4. 客户端对seq=5进行重传，服务端已经收到5，再次收到5，服务端要不要发ack？

5. UDP的包大小？64k

以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的

6. IP的包大小是基于什么的？

7. 操作系统合包的机制？是传输层还是协议层？

采用TCP协议进行数据传输，是不会造成IP分片的。若数据过大，只会在传输层进行数据分段，到了IP层就不用分片。IP分片产生的原因是网络层的MTU；而TCP分段产生原因是MSS。对于以太网，MSS为1460字节，而MUT（默认为1500）往往会大于MSS。IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组.。

因此TCP协议进行传输一般不会造成分片，而UDP传输可能会造成IP分片。

## 操作系统
1. 线程和进程的基本概念

2. 假设进程A：2个线程，进程B：4个线程【计算密集型，没有IO等待】。操作怎么分配进程A和进程B的时间呢？怎么CPU调度的基本单位呢？

3. 关于线程安全，

在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。

相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。

一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。
　　
也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括 static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。

编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。

说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。

4. 进程间通信的手段？有实际应用的例子吗？
管道 FIFO 信号量 共享内存 消息队列 socket

#数据库
俺不会，不好意西

# 面筋copy之术

## cache LRU
