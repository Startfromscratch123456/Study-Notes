
开头只提了下项目就木有了
1. vector的空间增长，以及为什么要这样做（为什么要另外申请空间而不是直接在后面构建空间）。
为需要的新容量分配足够的内存； 
将元素从原来的内存拷贝到新内存中； 
销毁原来的内存中的元素； 
归还原来的内存。  
后面的我没百度到，我使用内存池那个链表分配回答的，感觉面试官没什么反应也不知道对不对
2. vector和list的区别
vector数据结构
vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
因此能高效的进行随机存取，时间复杂度为o(1);
但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

list数据结构
list是由双向链表实现的，因此内存空间是不连续的。
只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
但由于链表的特点，能高效地进行插入和删除。
3. 用到了哪些stl容器
4. 空类大小，加一个虚函数之后呢
5. c++多态是如何实现的
C++支持多种形式的多态，从表现的形式来看，有虚函数、模板、重载等，从绑定时间来看，可以分成静态多态和动态多态，也称为编译期多态和运行期多态。    

动态多态的设计思想：对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。    
从上面的定义也可以看出，由于有了虚函数，因此动态多态是在运行时完成的，也可以叫做运行期多态，这造就了动态多态机制在处理异质对象集合时的强大威力（当然，也有了一点点性能损失）。

静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，这里的接口称之为隐式接口。客户端把操作这些对象的函数定义为模板，当需要操作什么类型的对象时，直接对模板指定该类型实参即可（或通过实参演绎获得）。      

相对于面向对象编程中，以显式接口和运行期多态（虚函数）实现动态多态，在模板编程及泛型编程中，是以隐式接口和编译器多态来实现静态多态。
6. 析构函数显示调用问题。
1）显式调用的时候，析构函数相当于的一个普通的成员函数；     
2）编译器隐式调用析构函数，如分配了对内存，显式调用析构的话引起重复释放堆内存的异常；       
3）把一个对象看作占用了部分栈内存，占用了部分堆内存（如果申请了的话），这样便于理解这个问题，系统隐式调用析构函数的时候，会加入释放栈内存的动作（而堆内存则由用户手工的释放）；用户显式调用析构函数的时候，只是单纯执行析构函数内的语句，不会释放栈内存，也不会摧毁对象。       
https://www.cnblogs.com/zsq1993/p/5838034.html
6. 虚函数表是怎么存放的，怎么选取要用的子类
- 虚函数表是全局共享的元素,即全局仅有一个.
- 虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.即虚函数表不是函数,不是程序代码,不肯能存储在代码段.
- 虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定,即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中. 
根据以上特征,虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.存放在全局数据区.     
https://blog.csdn.net/sunshinewave/article/details/51079204     
https://www.cnblogs.com/carter2000/archive/2012/04/28/2474960.html
7. 并发并行的概念，多进程和多线程的执行顺序 
提到了并发，那又不得不和并行作比较。并发是指在一段时间内同时做多个事情，比如在1点-2点洗碗、洗衣服等。而并行是指在同一时刻做多个事情，比如1点我左手画圆右手画方。两个很重要的区别就是“一段时间”和“同一时刻”.在操作系统中就是:    
　　1)并发就是在单核处理中同时处理多个任务.(这里的同时指的是逻辑上的同时)   
　　2)并行就是在多核处理器中同时处理多个任务.(这里的同时指的就是物理上的同时)   
线程的执行完全是自发的去抢CPU时间片，谁先抢到谁就先去执行       
8. 网络编程（不咋会），那说说如果你自己去实现一个网络库需要提供哪些API
```
编解码(包括tcp粘包问题)：消息到byte，byte到数据（即定制协议） 
由于tcp的传输是流的方式，再加上网络的不可靠性（丢包重传等），因此对于一个应用来讲，有粘包拆包问题

SOCKET连接（各种连接状态）管理；心跳机制（维持长连接/检活）； 
网络连接的创建相对成本较高，因此复用的必要性大大提升，就需要管理这些复用的对象

TCP参数设置； 
不同的应用，场景有所不同，因此，调整TCP参数可以优化使用

请求/响应处理； 
应用层定时器用于决定哪个请求超时，然后搭配一些后续的处理策略（比如延时重试等）

异步请求管理： 
支持异步调用，需要缓存请求，当网络IO有可读数据包时，判断是否是响应的； 
支持同步调用：在超时内，监听网卡IO是否有可读数据，超时后，响应失败，上层可以重试等； 
半双工：
```

网络库应该提供的功能：
3个半事件，详情请参考陈硕的《网络编程本质论》
可扩展的内存分配方式
对网络错误处理
异步、同步IO

网络库避免限制的决策：
对session集中式管理
对接收缓冲区与发送缓冲区的强制
需要做到协议无关

https://blog.csdn.net/chenyu2202863/article/details/12128369
9. 你平时看那些开源项目，怎么学的，怎么处理困难
10. 手写一个反转字符串编程
