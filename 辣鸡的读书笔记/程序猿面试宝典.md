## 程序设计基本概念
1. #include <filename.h> 和 #include "filename.h"的区别是前者的编译器从标准库路径开始搜索filename.h；后者编译器从用户的工作路径开始搜索。
2. 如何判断一段程序是由C编译还是C++编译的？     
C++编译时定义了_cplusplus
C编译时定义了_STDC_
3. main主函数执行完毕后，可以在执行一段代码。使用atexit()函数注册一个函数即可。

对C语言有所了解的人都知道main函数是整个程序的入口，但是其实不然，在内核中可以使用链接器来设置程序的开始地方。当内核使⽤⼀个exec函数执⾏C程序时，在调⽤main函数之前先调⽤⼀个特殊的启动例程，可执⾏程序将此例程指定为程序的起始地址。启动例程从内核获取命令⾏参数和环境变量，然后为调⽤main函数做好准备。

前面我们关注的是程序开始进入时的调用函数，而atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数（函数原型：int atexit (void (*)(void))）：

⼀个进程可以登记若⼲个（具体⾃⼰验证⼀下）个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理函数， atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反（网上很多说造成顺序相反的原因是参数压栈造成的，参数的压栈是先进后出，和函数的栈帧相同），如果⼀个函数被多次登记，也会被多次调⽤。

>以下函数的调用时程序异常或者正常终止：
进程终⽌的⽅式有8种，前5种为正常终⽌，后三种为异常终⽌：
1 从main函数返回；
2 调⽤exit函数；
3 调⽤_exit或_Exit；
4 最后⼀个线程从启动例程返回；
5 最后⼀个线程调⽤pthread_exit；
6 调⽤abort函数；
7 接到⼀个信号并终⽌；
8 最后⼀个线程对取消请求做出响应。

exit()和_exit()以及_Exit()函数的本质区别是是否立即进入内核，_exit()以及_Exit()函数都是在调用后立即进入内核，而不会执行一些清理处理，但是exit()则会执行一些清理处理，这也是为什么会存在atexit()函数的原因，因为exit()函数需要执行清理处理，需要执行一系列的操作，这些终止处理函数实际上就是完成各种所谓的清除操作的实际执行体。

下面我们来验证atexit的调用顺序和退出顺序：
```
#include<stdio.h>
#include<stdlib.h>
 
void func1()
{
	printf("The process is done...\n");
}
void func2()
{
	printf("Clean up the processing\n");
}
void func3()
{
	printf("Exit sucessful..\n");
}
int main()
{
	atexit(func1);
	atexit(func2);
	atexit(func3);
	exit(0);
}
执行结果：
Exit sucessful..
Clean up the processing
The process is done...
```
我们可以看到atexit函数的调用顺序是和登记顺序相反的。

atexit函数的用途也是比较广泛的：可以按照你予设的顺序摧毁全局变量（类），例如有个log类，你在其它的全局类里也有可能调用到Log类写日志。所以log 类必须最后被析构 。假如没有规定析构顺序，那么程序在退出时将有可能首先析构log类，那么其它的全局类在此时将无法正确写日志。 把数据写回文件, 删除临时文件, 这才是真正有用的.
## 预处理，const与sizeof
1.  C默认const是外部连接的，c++默认是内部连接的
2. strlen参数只能是char*并且必须是以'\0'结尾的；
strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度，而不是类型占内存的大小
3. 当时用了一个结构类型或变量时，sizeof返回实际的大小。当使用一静态的空间数组时，sizeof返货全部数组的尺寸。sizeof操作符不能返回被动态分配的数组或外部的数组的尺寸。
4. #pragma pack(n)可以改变对其字节大小
5. 内联函数和宏的差别：	
- 内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。而宏只是一个简单的替换。	
- 内联函数需要参数类型检查，这是内联函数跟宏相比的优势。
- inline是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到哪里去。
- inline一般只用于如下情况：
（1）一个函数不断被重复调用
（2）函数只有简单的几行，且函数内不包含for，while，switch语句
- 宏不是函数，只是在编译前（编译预处理阶段）将程序中有关字符替换成宏体
- inline函数是函数，但在编译中不单独产生代码，而是将有关代码嵌入到调用处。
## 指针与引用
1. 指针与引用的区别
（1）非空区别。引用不能为空值
（2）合法性测试。在使用引用前不需要测试它的合法性
（3）可修改区别
（4）应用区别
2. const常量赋值时，必须同时初始化
### this指针问题
- this只能在成员函数中使用，全局函数和静态函数都不能使用this
- this在成员函数开始前构造，在成员的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。比如
```
A a;
a.func(10);
此处编译器将会编译成：
A::func(&a, 10);
```
- 如果class和struct里面没有方法的话，他们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过exa返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有的话）。
- this指针会因为编译器不同而有不同的存放位置，可能是栈，也可能是寄存器，甚至是全局变量。
- 大多数编译器是通过ecx寄存器传递this指针的。事实上，这也是一个潜规则。
- 类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从累的函数定义完成后，它就在那儿，不会跑的。
- this指针只有在成员函数中才有定义。因此，如果你获得一个对象，也不能通过这个对象使用this指针。所以，我们无法知道一个对象的this指针的位置，但是在成员函数中是可以的(通过&this)
## 循环，递归和概率
1. 0-1背包问题		
>01背包问题：一个背包总容量为V，现在有N个物品，第i个 物品体积为weight[i]，价值为value[i]，现在往背包里面装东西，怎么装能使背包的内物品价值最大？

看到这个问题，可能会想到贪心算法，但是贪心其实是不对的。例如最少硬币找零问题，要用动态规划。动态规划思想就是解决子问题并记录子问题的解，这样就不用重复解决子问题了。

动态规划先找出子问题，我们可以这样考虑：在物品比较少，背包容量比较小时怎么解决？用一个数组f[i][j]表示，在只有i个物品，容量为j的情况下背包问题的最优解，那么当物品种类变大为i+1时，最优解是什么？第i+1个物品可以选择放进背包或者不放进背包（这也就是0和1），假设放进背包（前提是放得下），那么f[i+1][j]=f[i][j-weight[i+1]]+value[i+1]；如果不放进背包，那么f[i+1][j]=f[i][j]。

这就得出了状态转移方程：
```	
f[i+1][j]=max(f[i][j],f[i][j-weight[i+1]]+value[i+1])。
```
可以写出代码测试：
```
#include<iostream>
using namespace std;
#define  V 1500
unsigned int f[10][V];//全局变量，自动初始化为0
unsigned int weight[10];
unsigned int value[10];
#define  max(x,y)	(x)>(y)?(x):(y)
int main()
{
	
	int N,M;
	cin>>N;//物品个数
	cin>>M;//背包容量
	for (int i=1;i<=N; i++)
	{
		cin>>weight[i]>>value[i];
	}
	for (int i=1; i<=N; i++)
		for (int j=1; j<=M; j++)
		{
			if (weight[i]<=j)
			{
				f[i][j]=max(f[i-1][j],f[i-1][j-weight[i]]+value[i]);
			}
			else
				f[i][j]=f[i-1][j];
		}
	
	cout<<f[N][M]<<endl;//输出最优解
 
}
```
```
用f[0..v]表示，f[v]表示把前i件物品放入容量为v的背包里得到的价值。把i从1~n(n件)循环后，最后f[v]表示所求最大值。

*这里f[v]就相当于二位数组的f[i][v]。那么，如何得到f[i-1][v]和f[i-1][v-c[i]]+w[i]？（重点！思考）
首先要知道，我们是通过i从1到n的循环来依次表示前i件物品存入的状态。即：for i=1..N
现在思考如何能在是f[v]表示当前状态是容量为v的背包所得价值，而又使f[v]和f[v-c[i]]+w[i]标签前一状态的价值？

逆序！
这就是关键！
```
可以进一步优化内存使用。上面计算f[i][j]可以看出，在计算f[i][j]时只使用了f[i-1][0……j]，没有使用其他子问题，因此在存储子问题的解时，只存储f[i-1]子问题的解即可。这样可以用两个一维数组解决，一个存储子问题，一个存储正在解决的子问题。
再进一步思考，计算f[i][j]时只使用了f[i-1][0……j]，没有使用f[i-1][j+1]这样的话，我们先计算j的循环时，让j=M……1，只使用一个一维数组即可。

for i=1……N

for j=M……1
```
f[j]=max(f[j],f[j-weight[i]+value[i])
```
```
#include<iostream>
using namespace std;
#define  V 1500
unsigned int f[V];//全局变量，自动初始化为0
unsigned int weight[10];
unsigned int value[10];
#define  max(x,y)	(x)>(y)?(x):(y)
int main()
{
	
	int N,M;
	cin>>N;//物品个数
	cin>>M;//背包容量
	for (int i=1;i<=N; i++)
	{
		cin>>weight[i]>>value[i];
	}
	for (int i=1; i<=N; i++)
		for (int j=M; j>=1; j--)
		{
			if (weight[i]<=j)
			{
				f[j]=max(f[j],f[j-weight[i]]+value[i]);
			}			
		}
	
	cout<<f[M]<<endl;//输出最优解
 
}
```
2. 完全背包问题
在看完01背包问题，再来看完全背包问题：一个背包总容量为V，现在有N个物品，第i个 物品体积为weight[i]，价值为value[i]，每个物品都有无限多件，现在往背包里面装东西，怎么装能使背包的内物品价值最大？
对比一下，看到的区别是，完全背包问题中，物品有无限多件。往背包里面添加物品时，只要当前背包没装满，可以一直添加。那么状态转移方程为：
```
f[i+1][j]=max(f[i][j-k*weight[i+1]]+k*value[i+1])，其中0<=k<=V/weight[i+1]
```
使用内存为一维数组，伪代码
for i=1……N

for j=1……M

f[j]=max(f[j],f[j-weight[i]]+value[i])

和01背包问题唯一不同的是j是从1到M。01背包问题是在前一个子问题（i-1种物品）的基础上来解决当前问题（i种物品），向i-1种物品时的背包添加第i种物品；而完全背包问题是在解决当前问题（i种物品），向i种物品时的背包添加第i种物品。
代码如下：
```
#include<iostream>
using namespace std;
#define  V 1500
unsigned int f[V];//全局变量，自动初始化为0
unsigned int weight[10];
unsigned int value[10];
#define  max(x,y)	(x)>(y)?(x):(y)
int main()
{
	
	int N,M;
	cin>>N;//物品个数
	cin>>M;//背包容量
	for (int i=1;i<=N; i++)
	{
		cin>>weight[i]>>value[i];
	}
	for (int i=1; i<=N; i++)
		for (int j=1; j<=M; j++)
		{
			if (weight[i]<=j)
			{
				f[j]=max(f[j],f[j-weight[i]]+value[i]);
			}			
		}
	
	cout<<f[M]<<endl;//输出最优解
 
}
```
#### 注意，可以去查看《背包九讲》
## STL模板与容器
## 面向对象
1. 